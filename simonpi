#!/bin/bash

set -x
OPT=.

# You could overwrite paths using VARNAME=value ./simonpi

# Software used in this script.
AWK=awk
BSDTAR=bsdtar
DNSMASQ=dnsmasq
EXT4=mkfs.ext4
EXT4CHK=fsck.ext4
FDISK=fdisk
GREP=grep
IP=ip
IPTABLES=iptables
PS=ps
QEMUARM=qemu-system-arm
QEMUARM64=qemu-system-aarch64
VFAT=mkfs.vfat
VFATCHK=fsck.vfat
WGET=wget
PROGS=("$AWK" "$BSDTAR" "$DNSMASQ" "$EXT4" "$FDISK" "$GREP" "$IPTABLES" "$PS" "$QEMUARM" "$QEMUARM64" "$VFAT" "$WGET")

# Parameters, Folders and Files
SNDARG=$2
GIGA=$3
MODEL=$1
SIMONPIFOLDER=~/.simonpi
MOUNTFOLDERS=("boot" "root")
EXTPKGSFOLDER="$SIMONPIFOLDER/$MODEL/pkgs"
FILENAME="sd-arch-$MODEL-qemu.img"
ARCHIMG="ArchLinuxARM-$MODEL-latest.tar.gz"
FILES=("$ARCHIMG" "$ARCHIMG.md5")
IMGMOUNTED=
PMOUNTED=
START1=
START2=
LENGHT1=
LENGHT2=

# Loopback devices
DEVICE1=/dev/loop0
DEVICE2=/dev/loop1

# Text Colors
R='\e[0;31m'
G='\e[0;32m'
Y='\e[0;33m'
RST='\e[0m'

. $OPT/simonpiemu/runemu
. $OPT/simonpiemu/network

# Must be root to use this tool
if [[ ! $EUID -eq 0 ]];then
	if [[ -x "$(command -v sudo)" ]]; then
		exec sudo -u root -E bash "$0" "$@"
		exit $?
	else
		echo -e "[$Y!$RST] sudo is needed. Please run this script as root or install sudo."
		exit 1
	fi
fi

presetsGen() {
	if [[ $MODEL == rpi ]]; then
		echo -e "[$G+$RST] Injecting sda udev rules into $FILENAME ..."
		# It allows qemu virtualization and scsi functionality
		cat <<'EOF' > $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/udev/rules.d/90-qemu.rules
KERNEL=="sda", SYMLINK+="mmcblk0"
KERNEL=="sda?", SYMLINK+="mmcblk0p%n"
KERNEL=="sda2", SYMLINK+="root"
EOF
	fi

	echo -e "[$G+$RST] Injecting a motd and fstab to $FILENAME ..."
	# Prevent vfat corruption for boot partition
	mv $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/fstab \
	$SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/fstab.off
	cat <<EOF > $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/fstab
# /etc/fstab: static file system information
#
# <file system> <dir>   <type>  <options>       <dump>  <pass>
EOF
	cat <<'EOF' > $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/motd

        __                                                                        __
   ____/\_\    ___ ___                      ___     ___                    _____ /\_\
  /',__\/\ \ /' __` __`\      _______      / __`\ /' _ `\      _______    /\ '__`\/\ \
 /\__, `\ \ \/\ \/\ \/\ \    /\______\    /\ \L\ \/\ \/\ \    /\______\   \ \ \L\ \ \ \
 \/\____/\ \_\ \_\ \_\ \_\   \/______/    \ \____/\ \_\ \_\   \/______/    \ \ ,__/\ \_\
  \/___/  \/_/\/_/\/_/\/_/                 \/___/  \/_/\/_/                 \ \ \/  \/_/
                                                                             \ \_\
                                                                              \/_/
Written by Gianluca Boiano

In order to update the kernel image with pacman, you have to mount the boot partition.
Do not add entries for your boot partition to /etc/fstab unless you know what are you doing.

Remember to enable sshd on guest if you need it. Type:
systemctl enable sshd

To set tty lines type:
stty rows 28 columns 212
EOF
	echo -e "[$G+$RST] Fixing sshd on $FILENAME ..."
	mkdir $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/ssh/off

	mv $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/ssh/ssh_host* \
	$SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/ssh/off/

	echo -e "[$G+$RST] Disable rpi modules for qemu on $FILENAME ..."
	mv $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/modules-load.d/raspberry.conf \
	$SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/modules-load.d/raspberry.conf.off
}

presetsDel() {
	if [[ $MODEL == rpi ]]; then
		rm $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/udev/rules.d/90-qemu.rules
	fi
	mv $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/fstab.off \
	$SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/fstab

	rm $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/motd

	mv $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/ssh/off/ssh_host* \
	$SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/ssh/
	rm -rf $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/ssh/off/

	mv $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/modules-load.d/raspberry.conf.off \
	$SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/etc/modules-load.d/raspberry.conf

	sync
}

checkFs() {
	echo -e "[$G+$RST] Checking partitions to prevent failures ..."
	$VFATCHK $DEVICE1
	$EXT4CHK $DEVICE2
}

checkModel() {
	if [[ $MODEL != rpi* ]]; then
		echo "Please select the rpi model"
		echo "Available:	rpi	rpi-2	rpi-3"
		exit 1
	fi
}

checkDeps() {
	for i in "${PROGS[@]}"; do
		if [ $(which $i 2>/dev/null) ]; then
			echo -e "[$G+$RST] $i executable found"
		else
			echo -e "[$R-$RST] $i executable not found. Please install it on your distro"
			exit 1;
		fi
	done
}

checkMount() {
	if [ $SNDARG = "-r" ]; then
		if [ $IMGMOUNTED = "0" ] && [ $PMOUNTED = "0" ]; then
			mapImg
			mountImg
			mountParts
			presetsGen
		elif [ $IMGMOUNTED = "1" ] && [ $PMOUNTED = "0" ]; then
			mountParts
			presetsGen
		elif [ $PMOUNTED = "1" ]; then
			return
		else
			exit 1
		fi
	fi

	if [ $SNDARG = "-c" ]; then
		if [ $IMGMOUNTED = "0" ] && [ $PMOUNTED = "0" ]; then
			mapImg
			mountImg
		elif [ $IMGMOUNTED = "1" ] && [ $PMOUNTED = "0" ]; then
			return
		elif [ $PMOUNTED = "1" ]; then
			umountParts
		else
			exit 1
		fi
	fi

	if [ $SNDARG = "-e" ] || [ $SNDARG = "-p" ]; then
		if [ $IMGMOUNTED = "0" ] && [ $PMOUNTED = "0" ]; then
			return
		elif [ $IMGMOUNTED = "1" ] && [ $PMOUNTED = "0" ]; then
			umountImg
		elif [ $PMOUNTED = "1" ]; then
			umountParts
			umountImg
		fi
	fi

	if [ $SNDARG = "-m" ]; then
		if [ $IMGMOUNTED = "0" ] && [ $PMOUNTED = "0" ]; then
			mapImg
			mountImg
			mountParts
		elif [ $IMGMOUNTED = "1" ] && [ $PMOUNTED = "0" ]; then
			mountParts
		elif [ $PMOUNTED = "1" ]; then
			return
		else
			exit 1
		fi
	fi
}

isMounted() {
	if [ ! -f $SIMONPIFOLDER/$FILENAME ]; then
		echo -e "[$Y!$RST] No sd image to use on QEMU. Perhaps you have purged $FILENAME."
		IMGMOUNTED=2
		PMOUNTED=2
	elif [[ $(mount | grep $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[0]}) ]]; then
		IMGMOUNTED=1
		PMOUNTED=1
	elif [[ ! $(mount | grep $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[0]}) ]] && [[ $(mount | grep $DEVICE1) ]]; then
		IMGMOUNTED=0
		PMOUNTED=1
	else
		IMGMOUNTED=0
		PMOUNTED=0
	fi
}

customContent() {
	if [ -d $EXTPKGSFOLDER ]; then
		echo -e "[$Y!$RST] $EXTPKGSFOLDER folder is present"
		if [ "$(ls $EXTPKGSFOLDER)" ]; then
			echo -e "[$Y!$RST] Copying custom content to $FILENAME ..."
			for i in $(ls $EXTPKGSFOLDER); do
				echo -e "	[$G+$RST] Copying $i in /home/alarm ..."
				cp $EXTPKGSFOLDER/$i $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/home/alarm
				sync
			done
		else
			echo -e "[$Y!$RST] $EXTPKGSFOLDER is empty"
		fi
	else
		echo -e "[$Y!$RST] $EXTPKGSFOLDER folder not present. Creating ..."
		mkdir -p $EXTPKGSFOLDER
		echo -e "[$Y!$RST] You could add custom content on img copying it under $EXTPKGSFOLDER"
	fi
}

checkFolders() {
	for i in ${MOUNTFOLDERS[@]}; do
		if [ -d "$SIMONPIFOLDER/$MODEL/$i" ]; then
			echo -e "[$Y!$RST] $MODEL/$i folder is present"
		else
			echo -e "[$G+$RST] Creating $MODEL/$i folder ..."
			mkdir -p "$SIMONPIFOLDER/$MODEL/$i"
		fi
	done
}

formatLoDevices() {
	echo -e "[$G+$RST] Creating partitions on disk image named $FILENAME ..."
	$VFAT -n boot -F 32 $DEVICE1 > /dev/null 2>&1
	$EXT4 -L rootfs $DEVICE2 > /dev/null 2>&1
	sync
}

integrityCheck() {
	cd $SIMONPIFOLDER/$MODEL
	if md5sum --status -c "$ARCHIMG.md5"; then
		echo -e "[$G+$RST] Integrity check successfully completed"
		return 0
	else
		echo -e "[$R-$RST] Integrity check failed, please retry to download"
		exit 1
	fi
}

downloadArchArm() {
	echo -e "[$G+$RST] Downloading ..."
	for i in ${FILES[@]}; do
		if [ -f $SIMONPIFOLDER/$MODEL/$i ]; then
			echo -e "[$Y!$RST] $i is present";
		else
			$WGET "http://os.archlinuxarm.org/os/$i" -P "$SIMONPIFOLDER/$MODEL" -q --show-progress --continue
		fi
	done
	integrityCheck
}

mountParts() {
	checkFolders
	echo -e "[$G+$RST] Mounting partitions of $FILENAME ..."
	mount $DEVICE1 "$SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[0]}"
	mount $DEVICE2 "$SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}"
}

umountParts() {
	echo -e "[$G+$RST] Umounting partitions of $FILENAME ..."
	mountpointloop1=$(grep $DEVICE1 /proc/mounts | cut -d ' ' -f 2)
	mountpointloop2=$(grep $DEVICE2 /proc/mounts | cut -d ' ' -f 2)
	mountpoints=("$mountpointloop1" "$mountpointloop2")

	for i in ${mountpoints[@]}; do
		umount "$i"
	done
}

listStorage() {
	checkFolders
	echo -e "[$Y!$RST] Content of $SIMONPIFOLDER/$MODEL"
	ls $SIMONPIFOLDER/$MODEL
}

mapImg() {
	echo -e "[$G+$RST] Mapping lenghts of partitions ..."
	START1=$(fdisk -lo Start $SIMONPIFOLDER/$FILENAME | tail -n 2 | head -n -1)
	START2=$(fdisk -lo Start $SIMONPIFOLDER/$FILENAME | tail -n 1)
	LENGTH1=$(fdisk -lo Sectors $SIMONPIFOLDER/$FILENAME | tail -n 2 | head -n -1)
	LENGHT2=$(fdisk -lo Sectors $SIMONPIFOLDER/$FILENAME | tail -n 1)
}

mountImg() {
	echo -e "[$G+$RST] Mounting disk image named $FILENAME ..."
	losetup -o $(( START1*512 )) --sizelimit $(( LENGHT1*512 )) $DEVICE1 $SIMONPIFOLDER/$FILENAME > /dev/null 2>&1
	losetup -o $(( START2*512 )) --sizelimit $(( LENGHT2*512 )) $DEVICE2 $SIMONPIFOLDER/$FILENAME > /dev/null 2>&1
}

umountImg() {
	echo -e "[$G+$RST] Unmounting disk image named $FILENAME ..."
	losetup -D
}

createImg() {
	isaNumber='^[0-9]+$'
	if ! [[ $GIGA =~ $isaNumber ]] || [ -z $GIGA ]; then
		echo -e "[$R-$RST] Please specify a size in GB"
		exit 1
	elif [ $GIGA -lt 2 ]; then
		echo -e "[$R-$RST] Please specify a size >= 2 GB"
		exit 1
	fi
	checkDeps
	isMounted
	downloadArchArm

	if [ -e "$SIMONPIFOLDER/$FILENAME" ]; then
		echo -e "[$Y!$RST] An $FILENAME file already exists. Please delete it"
		exit 1
	else
		SIZE=$(( GIGA*256 ))
		echo -e "[$G+$RST] Creating a $GIGA GB disk image named $FILENAME ..."
		dd if=/dev/zero of="$SIMONPIFOLDER/$FILENAME" bs=4M count="$SIZE" > /dev/null 2>&1

		echo -e "[$G+$RST] Creating partition table on $FILENAME ..."
		(echo o; echo n; echo p; echo 1; echo 8192; echo +100M; echo t; echo c; \
		echo n; echo p; echo 2; echo 8192; echo ; echo ; echo w) | \
		$FDISK -H 255 -S 63 "$SIMONPIFOLDER/$FILENAME" >/dev/null 2>&1
	fi
	sync
	mapImg
	mountImg
	formatLoDevices
	mountParts
	echo -e "[$G+$RST] Extracting $ARCHIMG to $FILENAME ..."
	$BSDTAR -xpf $SIMONPIFOLDER/$MODEL/$ARCHIMG -C "$SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}"
	sync
	customContent
	mv $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[1]}/boot/* $SIMONPIFOLDER/$MODEL/${MOUNTFOLDERS[0]}
	sync
	umountParts
	umountImg
	echo -e "[$G+$RST] DONE"
}

purge () {
	rm -rf $SIMONPIFOLDER/$FILENAME
	echo -e "[$G+$RST] Soft cleaning ..."
}

purgeEverything() {
	rm -rf $SIMONPIFOLDER/$MODEL/
	echo -e "[$G+$RST] Hard cleaning ..."
}

help () {
	echo "Create a raw partitioned img for rpi-(1-2-3) emulation on QEMU"
	echo -e "Default storage is in $G$SIMONPIFOLDER$RST"
	echo "usage: ./simonpi MODEL [<opts>]"
	echo "	Available MODELs:	rpi	rpi-2	rpi-3"
	echo "	<opts>	-h			print this message"
	echo "		-c			check filesystem integrity for .img file"
	echo "		-e			purge everything in storage folder"
	echo "		-k			kill every instance and network virtual interface"
	echo "		-l			list files in storage folder"
	echo "		-m			mount only loop devices ($DEVICE1, $DEVICE2)"
	echo "		-p			purge everything except Arch Linux archives"
	echo "		-r			run QEMU processor emulator for defined model"
	echo "		-s	<size in G>	write a partitioned raw .img file with Arch Linux"
	echo "		-u			unmount ${MOUNTFOLDERS[0]} and ${MOUNTFOLDERS[1]} folders"
	echo "examples:"
	echo "	./simonpi rpi-3 -s 2		create a 2GB sd .img for rpi-3"
	echo "	./simonpi rpi-2 -p		purge everything related to rpi-2 img creation"
	exit 0
}

process_args () {
	# Process other arguments.
	case "$1" in
		-h    ) help ;;
		rpi   ) checkModel ;;
		rpi-2 ) checkModel ;;
		rpi-3 ) checkModel ;;
		-*    ) help ;;
		*     ) checkModel ;;
	esac
	case "$2" in
		-c	  ) checkMount && checkFs ;;
		-e	  ) checkMount && purge && purgeEverything ;;
		-k	  ) checkQemu && killQemu && killNetwork ;;
		-l	  ) listStorage ;;
		-m	  ) isMounted && checkMount ;;
		-p	  ) isMounted && checkMount && purge ;;
		-r    ) isMounted && checkMount && run_emu ;;
		-s    ) createImg ;;
		-u    ) isMounted && umountParts && umountImg ;;
		*     ) echo 'Please type -h for details' ;;
	esac
}

process_args $@;
